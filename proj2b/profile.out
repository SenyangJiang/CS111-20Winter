Total: 1239 samples
    1132  91.4%  91.4%     1238  99.9% thread_func
      17   1.4%  92.7%       17   1.4% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:200
      16   1.3%  94.0%       16   1.3% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:165
      14   1.1%  95.2%       52   4.2% SortedList_insert
      14   1.1%  96.3%       53   4.3% SortedList_lookup
      12   1.0%  97.3%       12   1.0% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1721
       5   0.4%  97.7%        5   0.4% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:205
       5   0.4%  98.1%        5   0.4% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1730
       4   0.3%  98.4%        4   0.3% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:204
       3   0.2%  98.6%        3   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:130
       3   0.2%  98.9%        3   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1720
       3   0.2%  99.1%        3   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1729
       2   0.2%  99.3%        2   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:160
       2   0.2%  99.4%        2   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:202
       2   0.2%  99.6%        2   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1714
       2   0.2%  99.8%        2   0.2% _init
       1   0.1%  99.8%        1   0.1% ?? /usr/src/debug////////glibc-2.17-c758a686/misc/../sysdeps/unix/syscall-template.S:81
       1   0.1%  99.9%        1   0.1% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:203
       1   0.1% 100.0%        1   0.1% 0x00007ffce44837a8
       0   0.0% 100.0%     1238  99.9% ?? /usr/src/debug////////glibc-2.17-c758a686/misc/../sysdeps/unix/sysv/linux/x86_64/clone.S:111
       0   0.0% 100.0%        1   0.1% __GI___clock_gettime
       0   0.0% 100.0%        1   0.1% __libc_start_main
       0   0.0% 100.0%        1   0.1% _start
       0   0.0% 100.0%        1   0.1% allocate_stack
       0   0.0% 100.0%        1   0.1% main
       0   0.0% 100.0%     1238  99.9% start_thread
ROUTINE ====================== thread_func in /u/cs/ugrad/senyang/CS111-20Winter/proj2b/lab2_list.c
  1132   1238 Total samples (flat / cumulative)
     .      .   43:         hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
     .      .   44: 
     .      .   45:     return hash;
     .      .   46: }
     .      .   47: 
---
     .      .   48: void *thread_func(void *thread_id) {
     .      .   49:   long tid = (long)thread_id;
     .      .   50:   struct timespec start, end;
     .      .   51:   long total_time = 0;
     .      .   52:   long list_id;
     .      .   53:   // inserts them all into a list
     .      .   54:   for(int i = tid*num_iter; i < (tid+1)*num_iter; i++) {
     .      .   55:     list_id = hash(elements[i].key) % num_lists;
     .      .   56:     if(sync_opt == 'm') {
     .      .   57:       clock_gettime(CLOCK_MONOTONIC, &start);
     .      .   58:       pthread_mutex_lock(&(sublists[list_id].mutexlist));
     .      .   59:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .   60:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .      .   61:       SortedList_insert(&(sublists[list_id].head), &elements[i]);
     .      .   62:       pthread_mutex_unlock(&(sublists[list_id].mutexlist));
     .      .   63:     }
     .      .   64:     else if(sync_opt == 's') {
     .      .   65:       clock_gettime(CLOCK_MONOTONIC, &start);
   551    551   66:       while (__sync_lock_test_and_set(&(sublists[list_id].lock), 1));
     .      .   67:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .   68:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .     52   69:       SortedList_insert(&(sublists[list_id].head), &elements[i]);
     .      .   70:       __sync_lock_release(&(sublists[list_id].lock));
     .      .   71:     }
     .      .   72:     else{
     .      .   73:       SortedList_insert(&(sublists[list_id].head), &elements[i]);
     .      .   74:     }
     .      .   75:   }
     .      .   76:   // get the list length
     .      .   77:   int total_len = 0;
     .      .   78:   int len = 0;
     .      .   79:   for(int i = 0; i < num_lists; i++) {
     .      .   80:     if(sync_opt == 'm') {
     .      .   81:       clock_gettime(CLOCK_MONOTONIC, &start);
     .      .   82:       pthread_mutex_lock(&(sublists[i].mutexlist));
     .      .   83:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .   84:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .      .   85:       len = SortedList_length(&(sublists[i].head));
     .      .   86:       pthread_mutex_unlock(&(sublists[i].mutexlist));
     .      .   87:     }
     .      .   88:     else if(sync_opt == 's') {
     .      .   89:       clock_gettime(CLOCK_MONOTONIC, &start);
     .      .   90:       while (__sync_lock_test_and_set(&(sublists[i].lock), 1));
     .      .   91:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .   92:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .      .   93:       len = SortedList_length(&(sublists[i].head));
     .      .   94:       __sync_lock_release(&(sublists[i].lock));
     .      .   95:     }
     .      .   96:     else{
     .      .   97:       len = SortedList_length(&(sublists[i].head));
     .      .   98:     }
     .      .   99: 
     .      .  100:     if(len == -1) {
     .      .  101:       fprintf(stderr, "Failure in finding list length\n");
     .      .  102:       exit(2);
     .      .  103:     }
     .      .  104:     total_len += len;
     .      .  105:   }
     .      .  106:   // looks up and deletes each of the keys it had previously inserted
     .      .  107:   for(int i = tid*num_iter; i < (tid+1)*num_iter; i++) {
     .      .  108:     SortedListElement_t *e;
     .      .  109:     int rc;
     .      .  110:     list_id = hash(elements[i].key) % num_lists;
     .      .  111:     if(sync_opt == 'm') {
     .      .  112:       clock_gettime(CLOCK_MONOTONIC, &start);
     .      .  113:       pthread_mutex_lock(&(sublists[list_id].mutexlist));
     .      .  114:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .  115:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .      .  116:       e = SortedList_lookup(&(sublists[list_id].head), elements[i].key);
     .      .  117:       if(e == NULL) {
     .      .  118: 	fprintf(stderr, "Failure in looking up list element\n");
     .      .  119: 	exit(2);
     .      .  120:       }
     .      .  121:       rc = SortedList_delete(e);
     .      .  122:       if(rc == 1) {
     .      .  123: 	fprintf(stderr, "Failure in deleting list element\n");
     .      .  124: 	exit(2);
     .      .  125:       }
     .      .  126:       pthread_mutex_unlock (&(sublists[list_id].mutexlist));
     .      .  127:     }
     .      .  128:     else if(sync_opt == 's') {
     .      .  129:       clock_gettime(CLOCK_MONOTONIC, &start);
   581    581  130:       while (__sync_lock_test_and_set(&(sublists[list_id].lock), 1));
     .      1  131:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .  132:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .     53  133:       e = SortedList_lookup(&(sublists[list_id].head), elements[i].key);
     .      .  134:       if(e == NULL) {
     .      .  135: 	fprintf(stderr, "Failure in looking up list element\n");
     .      .  136: 	exit(2);
     .      .  137:       }
     .      .  138:       rc = SortedList_delete(e);
     .      .  139:       if(rc == 1) {
     .      .  140: 	fprintf(stderr, "Failure in deleting list element\n");
     .      .  141: 	exit(2);
     .      .  142:       }
     .      .  143:       __sync_lock_release(&(sublists[list_id].lock));
     .      .  144:     }
     .      .  145:     else{
     .      .  146:       e = SortedList_lookup(&(sublists[list_id].head), elements[i].key);
     .      .  147:       if(e == NULL) {
     .      .  148: 	fprintf(stderr, "Failure in looking up list element\n");
     .      .  149: 	exit(2);
     .      .  150:       }
     .      .  151:       rc = SortedList_delete(e);
     .      .  152:       if(rc == 1) {
     .      .  153: 	fprintf(stderr, "Failure in deleting list element\n");
     .      .  154: 	exit(2);
     .      .  155:       }
     .      .  156:     }
     .      .  157:   }
     .      .  158:   pthread_exit((void *)total_time);
---
     .      .  159: }
     .      .  160: int main(int argc, char **argv)
     .      .  161: {
     .      .  162:   int opt;
     .      .  163:   struct option long_options[] = {{"threads", required_argument, NULL, 't'},
ROUTINE ====================== thread_func in /u/cs/ugrad/senyang/CS111-20Winter/proj2b/lab2_list.c
  1132   1238 Total samples (flat / cumulative)
     .      .   43:         hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
     .      .   44: 
     .      .   45:     return hash;
     .      .   46: }
     .      .   47: 
---
     .      .   48: void *thread_func(void *thread_id) {
     .      .   49:   long tid = (long)thread_id;
     .      .   50:   struct timespec start, end;
     .      .   51:   long total_time = 0;
     .      .   52:   long list_id;
     .      .   53:   // inserts them all into a list
     .      .   54:   for(int i = tid*num_iter; i < (tid+1)*num_iter; i++) {
     .      .   55:     list_id = hash(elements[i].key) % num_lists;
     .      .   56:     if(sync_opt == 'm') {
     .      .   57:       clock_gettime(CLOCK_MONOTONIC, &start);
     .      .   58:       pthread_mutex_lock(&(sublists[list_id].mutexlist));
     .      .   59:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .   60:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .      .   61:       SortedList_insert(&(sublists[list_id].head), &elements[i]);
     .      .   62:       pthread_mutex_unlock(&(sublists[list_id].mutexlist));
     .      .   63:     }
     .      .   64:     else if(sync_opt == 's') {
     .      .   65:       clock_gettime(CLOCK_MONOTONIC, &start);
   551    551   66:       while (__sync_lock_test_and_set(&(sublists[list_id].lock), 1));
     .      .   67:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .   68:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .     52   69:       SortedList_insert(&(sublists[list_id].head), &elements[i]);
     .      .   70:       __sync_lock_release(&(sublists[list_id].lock));
     .      .   71:     }
     .      .   72:     else{
     .      .   73:       SortedList_insert(&(sublists[list_id].head), &elements[i]);
     .      .   74:     }
     .      .   75:   }
     .      .   76:   // get the list length
     .      .   77:   int total_len = 0;
     .      .   78:   int len = 0;
     .      .   79:   for(int i = 0; i < num_lists; i++) {
     .      .   80:     if(sync_opt == 'm') {
     .      .   81:       clock_gettime(CLOCK_MONOTONIC, &start);
     .      .   82:       pthread_mutex_lock(&(sublists[i].mutexlist));
     .      .   83:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .   84:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .      .   85:       len = SortedList_length(&(sublists[i].head));
     .      .   86:       pthread_mutex_unlock(&(sublists[i].mutexlist));
     .      .   87:     }
     .      .   88:     else if(sync_opt == 's') {
     .      .   89:       clock_gettime(CLOCK_MONOTONIC, &start);
     .      .   90:       while (__sync_lock_test_and_set(&(sublists[i].lock), 1));
     .      .   91:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .   92:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .      .   93:       len = SortedList_length(&(sublists[i].head));
     .      .   94:       __sync_lock_release(&(sublists[i].lock));
     .      .   95:     }
     .      .   96:     else{
     .      .   97:       len = SortedList_length(&(sublists[i].head));
     .      .   98:     }
     .      .   99: 
     .      .  100:     if(len == -1) {
     .      .  101:       fprintf(stderr, "Failure in finding list length\n");
     .      .  102:       exit(2);
     .      .  103:     }
     .      .  104:     total_len += len;
     .      .  105:   }
     .      .  106:   // looks up and deletes each of the keys it had previously inserted
     .      .  107:   for(int i = tid*num_iter; i < (tid+1)*num_iter; i++) {
     .      .  108:     SortedListElement_t *e;
     .      .  109:     int rc;
     .      .  110:     list_id = hash(elements[i].key) % num_lists;
     .      .  111:     if(sync_opt == 'm') {
     .      .  112:       clock_gettime(CLOCK_MONOTONIC, &start);
     .      .  113:       pthread_mutex_lock(&(sublists[list_id].mutexlist));
     .      .  114:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .  115:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .      .  116:       e = SortedList_lookup(&(sublists[list_id].head), elements[i].key);
     .      .  117:       if(e == NULL) {
     .      .  118: 	fprintf(stderr, "Failure in looking up list element\n");
     .      .  119: 	exit(2);
     .      .  120:       }
     .      .  121:       rc = SortedList_delete(e);
     .      .  122:       if(rc == 1) {
     .      .  123: 	fprintf(stderr, "Failure in deleting list element\n");
     .      .  124: 	exit(2);
     .      .  125:       }
     .      .  126:       pthread_mutex_unlock (&(sublists[list_id].mutexlist));
     .      .  127:     }
     .      .  128:     else if(sync_opt == 's') {
     .      .  129:       clock_gettime(CLOCK_MONOTONIC, &start);
   581    581  130:       while (__sync_lock_test_and_set(&(sublists[list_id].lock), 1));
     .      1  131:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .  132:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .     53  133:       e = SortedList_lookup(&(sublists[list_id].head), elements[i].key);
     .      .  134:       if(e == NULL) {
     .      .  135: 	fprintf(stderr, "Failure in looking up list element\n");
     .      .  136: 	exit(2);
     .      .  137:       }
     .      .  138:       rc = SortedList_delete(e);
     .      .  139:       if(rc == 1) {
     .      .  140: 	fprintf(stderr, "Failure in deleting list element\n");
     .      .  141: 	exit(2);
     .      .  142:       }
     .      .  143:       __sync_lock_release(&(sublists[list_id].lock));
     .      .  144:     }
     .      .  145:     else{
     .      .  146:       e = SortedList_lookup(&(sublists[list_id].head), elements[i].key);
     .      .  147:       if(e == NULL) {
     .      .  148: 	fprintf(stderr, "Failure in looking up list element\n");
     .      .  149: 	exit(2);
     .      .  150:       }
     .      .  151:       rc = SortedList_delete(e);
     .      .  152:       if(rc == 1) {
     .      .  153: 	fprintf(stderr, "Failure in deleting list element\n");
     .      .  154: 	exit(2);
     .      .  155:       }
     .      .  156:     }
     .      .  157:   }
     .      .  158:   pthread_exit((void *)total_time);
---
     .      .  159: }
     .      .  160: int main(int argc, char **argv)
     .      .  161: {
     .      .  162:   int opt;
     .      .  163:   struct option long_options[] = {{"threads", required_argument, NULL, 't'},
