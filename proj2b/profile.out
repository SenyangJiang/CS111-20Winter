Total: 1041 samples
     878  84.3%  84.3%     1041 100.0% thread_func
      39   3.7%  88.1%       39   3.7% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:200
      22   2.1%  90.2%       22   2.1% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1721
      18   1.7%  91.9%       96   9.2% SortedList_insert
      17   1.6%  93.6%       17   1.6% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:165
      10   1.0%  94.5%       10   1.0% _init
       9   0.9%  95.4%        9   0.9% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1720
       8   0.8%  96.2%        8   0.8% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1729
       8   0.8%  96.9%       67   6.4% SortedList_lookup
       7   0.7%  97.6%        7   0.7% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:205
       7   0.7%  98.3%        7   0.7% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:1730
       5   0.5%  98.8%        5   0.5% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:204
       4   0.4%  99.1%        4   0.4% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:160
       4   0.4%  99.5%        4   0.4% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:203
       3   0.3%  99.8%        3   0.3% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:130
       2   0.2% 100.0%        2   0.2% ?? /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/multiarch/strcmp-sse42.S:202
       0   0.0% 100.0%     1041 100.0% ?? /usr/src/debug////////glibc-2.17-c758a686/misc/../sysdeps/unix/sysv/linux/x86_64/clone.S:111
       0   0.0% 100.0%     1041 100.0% start_thread
ROUTINE ====================== thread_func in /u/cs/ugrad/senyang/CS111-20Winter/proj2b/lab2_list.c
   878   1041 Total samples (flat / cumulative)
     .      .   43:         hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
     .      .   44: 
     .      .   45:     return hash;
     .      .   46: }
     .      .   47: 
---
     .      .   48: void *thread_func(void *thread_id) {
     .      .   49:   long tid = (long)thread_id;
     .      .   50:   struct timespec start, end;
     .      .   51:   long total_time = 0;
     .      .   52:   long list_id;
     .      .   53:   // inserts them all into a list
     .      .   54:   for(int i = tid*num_iter; i < (tid+1)*num_iter; i++) {
     .      .   55:     list_id = hash(elements[i].key) % num_lists;
     .      .   56:     if(sync_opt == 'm') {
     .      .   57:       clock_gettime(CLOCK_MONOTONIC, &start);
     .      .   58:       pthread_mutex_lock(&(sublists[list_id].mutexlist));
     .      .   59:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .   60:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .      .   61:       SortedList_insert(&(sublists[list_id].head), &elements[i]);
     .      .   62:       pthread_mutex_unlock(&(sublists[list_id].mutexlist));
     .      .   63:     }
     .      .   64:     else if(sync_opt == 's') {
     .      .   65:       clock_gettime(CLOCK_MONOTONIC, &start);
   435    435   66:       while (__sync_lock_test_and_set(&(sublists[list_id].lock), 1));
     .      .   67:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .   68:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .     96   69:       SortedList_insert(&(sublists[list_id].head), &elements[i]);
     .      .   70:       __sync_lock_release(&(sublists[list_id].lock));
     .      .   71:     }
     .      .   72:     else{
     .      .   73:       SortedList_insert(&(sublists[list_id].head), &elements[i]);
     .      .   74:     }
     .      .   75:   }
     .      .   76:   // get the list length
     .      .   77:   int total_len = 0;
     .      .   78:   int len = 0;
     .      .   79:   for(int i = 0; i < num_lists; i++) {
     .      .   80:     if(sync_opt == 'm') {
     .      .   81:       clock_gettime(CLOCK_MONOTONIC, &start);
     .      .   82:       pthread_mutex_lock(&(sublists[i].mutexlist));
     .      .   83:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .   84:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .      .   85:       len = SortedList_length(&(sublists[i].head));
     .      .   86:       pthread_mutex_unlock(&(sublists[i].mutexlist));
     .      .   87:     }
     .      .   88:     else if(sync_opt == 's') {
     .      .   89:       clock_gettime(CLOCK_MONOTONIC, &start);
     .      .   90:       while (__sync_lock_test_and_set(&(sublists[i].lock), 1));
     .      .   91:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .   92:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .      .   93:       len = SortedList_length(&(sublists[i].head));
     .      .   94:       __sync_lock_release(&(sublists[i].lock));
     .      .   95:     }
     .      .   96:     else{
     .      .   97:       len = SortedList_length(&(sublists[i].head));
     .      .   98:     }
     .      .   99: 
     .      .  100:     if(len == -1) {
     .      .  101:       fprintf(stderr, "Failure in finding list length\n");
     .      .  102:       exit(2);
     .      .  103:     }
     .      .  104:     total_len += len;
     .      .  105:   }
     .      .  106:   // looks up and deletes each of the keys it had previously inserted
     .      .  107:   for(int i = tid*num_iter; i < (tid+1)*num_iter; i++) {
     .      .  108:     SortedListElement_t *e;
     .      .  109:     int rc;
     .      .  110:     list_id = hash(elements[i].key) % num_lists;
     .      .  111:     if(sync_opt == 'm') {
     .      .  112:       clock_gettime(CLOCK_MONOTONIC, &start);
     .      .  113:       pthread_mutex_lock(&(sublists[list_id].mutexlist));
     .      .  114:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .  115:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .      .  116:       e = SortedList_lookup(&(sublists[list_id].head), elements[i].key);
     .      .  117:       if(e == NULL) {
     .      .  118: 	fprintf(stderr, "Failure in looking up list element\n");
     .      .  119: 	exit(2);
     .      .  120:       }
     .      .  121:       rc = SortedList_delete(e);
     .      .  122:       if(rc == 1) {
     .      .  123: 	fprintf(stderr, "Failure in deleting list element\n");
     .      .  124: 	exit(2);
     .      .  125:       }
     .      .  126:       pthread_mutex_unlock (&(sublists[list_id].mutexlist));
     .      .  127:     }
     .      .  128:     else if(sync_opt == 's') {
     .      .  129:       clock_gettime(CLOCK_MONOTONIC, &start);
   443    443  130:       while (__sync_lock_test_and_set(&(sublists[list_id].lock), 1));
     .      .  131:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .  132:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .     67  133:       e = SortedList_lookup(&(sublists[list_id].head), elements[i].key);
     .      .  134:       if(e == NULL) {
     .      .  135: 	fprintf(stderr, "Failure in looking up list element\n");
     .      .  136: 	exit(2);
     .      .  137:       }
     .      .  138:       rc = SortedList_delete(e);
     .      .  139:       if(rc == 1) {
     .      .  140: 	fprintf(stderr, "Failure in deleting list element\n");
     .      .  141: 	exit(2);
     .      .  142:       }
     .      .  143:       __sync_lock_release(&(sublists[list_id].lock));
     .      .  144:     }
     .      .  145:     else{
     .      .  146:       e = SortedList_lookup(&(sublists[list_id].head), elements[i].key);
     .      .  147:       if(e == NULL) {
     .      .  148: 	fprintf(stderr, "Failure in looking up list element\n");
     .      .  149: 	exit(2);
     .      .  150:       }
     .      .  151:       rc = SortedList_delete(e);
     .      .  152:       if(rc == 1) {
     .      .  153: 	fprintf(stderr, "Failure in deleting list element\n");
     .      .  154: 	exit(2);
     .      .  155:       }
     .      .  156:     }
     .      .  157:   }
     .      .  158:   pthread_exit((void *)total_time);
---
     .      .  159: }
     .      .  160: int main(int argc, char **argv)
     .      .  161: {
     .      .  162:   int opt;
     .      .  163:   struct option long_options[] = {{"threads", required_argument, NULL, 't'},
ROUTINE ====================== thread_func in /u/cs/ugrad/senyang/CS111-20Winter/proj2b/lab2_list.c
   878   1041 Total samples (flat / cumulative)
     .      .   43:         hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
     .      .   44: 
     .      .   45:     return hash;
     .      .   46: }
     .      .   47: 
---
     .      .   48: void *thread_func(void *thread_id) {
     .      .   49:   long tid = (long)thread_id;
     .      .   50:   struct timespec start, end;
     .      .   51:   long total_time = 0;
     .      .   52:   long list_id;
     .      .   53:   // inserts them all into a list
     .      .   54:   for(int i = tid*num_iter; i < (tid+1)*num_iter; i++) {
     .      .   55:     list_id = hash(elements[i].key) % num_lists;
     .      .   56:     if(sync_opt == 'm') {
     .      .   57:       clock_gettime(CLOCK_MONOTONIC, &start);
     .      .   58:       pthread_mutex_lock(&(sublists[list_id].mutexlist));
     .      .   59:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .   60:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .      .   61:       SortedList_insert(&(sublists[list_id].head), &elements[i]);
     .      .   62:       pthread_mutex_unlock(&(sublists[list_id].mutexlist));
     .      .   63:     }
     .      .   64:     else if(sync_opt == 's') {
     .      .   65:       clock_gettime(CLOCK_MONOTONIC, &start);
   435    435   66:       while (__sync_lock_test_and_set(&(sublists[list_id].lock), 1));
     .      .   67:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .   68:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .     96   69:       SortedList_insert(&(sublists[list_id].head), &elements[i]);
     .      .   70:       __sync_lock_release(&(sublists[list_id].lock));
     .      .   71:     }
     .      .   72:     else{
     .      .   73:       SortedList_insert(&(sublists[list_id].head), &elements[i]);
     .      .   74:     }
     .      .   75:   }
     .      .   76:   // get the list length
     .      .   77:   int total_len = 0;
     .      .   78:   int len = 0;
     .      .   79:   for(int i = 0; i < num_lists; i++) {
     .      .   80:     if(sync_opt == 'm') {
     .      .   81:       clock_gettime(CLOCK_MONOTONIC, &start);
     .      .   82:       pthread_mutex_lock(&(sublists[i].mutexlist));
     .      .   83:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .   84:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .      .   85:       len = SortedList_length(&(sublists[i].head));
     .      .   86:       pthread_mutex_unlock(&(sublists[i].mutexlist));
     .      .   87:     }
     .      .   88:     else if(sync_opt == 's') {
     .      .   89:       clock_gettime(CLOCK_MONOTONIC, &start);
     .      .   90:       while (__sync_lock_test_and_set(&(sublists[i].lock), 1));
     .      .   91:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .   92:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .      .   93:       len = SortedList_length(&(sublists[i].head));
     .      .   94:       __sync_lock_release(&(sublists[i].lock));
     .      .   95:     }
     .      .   96:     else{
     .      .   97:       len = SortedList_length(&(sublists[i].head));
     .      .   98:     }
     .      .   99: 
     .      .  100:     if(len == -1) {
     .      .  101:       fprintf(stderr, "Failure in finding list length\n");
     .      .  102:       exit(2);
     .      .  103:     }
     .      .  104:     total_len += len;
     .      .  105:   }
     .      .  106:   // looks up and deletes each of the keys it had previously inserted
     .      .  107:   for(int i = tid*num_iter; i < (tid+1)*num_iter; i++) {
     .      .  108:     SortedListElement_t *e;
     .      .  109:     int rc;
     .      .  110:     list_id = hash(elements[i].key) % num_lists;
     .      .  111:     if(sync_opt == 'm') {
     .      .  112:       clock_gettime(CLOCK_MONOTONIC, &start);
     .      .  113:       pthread_mutex_lock(&(sublists[list_id].mutexlist));
     .      .  114:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .  115:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .      .  116:       e = SortedList_lookup(&(sublists[list_id].head), elements[i].key);
     .      .  117:       if(e == NULL) {
     .      .  118: 	fprintf(stderr, "Failure in looking up list element\n");
     .      .  119: 	exit(2);
     .      .  120:       }
     .      .  121:       rc = SortedList_delete(e);
     .      .  122:       if(rc == 1) {
     .      .  123: 	fprintf(stderr, "Failure in deleting list element\n");
     .      .  124: 	exit(2);
     .      .  125:       }
     .      .  126:       pthread_mutex_unlock (&(sublists[list_id].mutexlist));
     .      .  127:     }
     .      .  128:     else if(sync_opt == 's') {
     .      .  129:       clock_gettime(CLOCK_MONOTONIC, &start);
   443    443  130:       while (__sync_lock_test_and_set(&(sublists[list_id].lock), 1));
     .      .  131:       clock_gettime(CLOCK_MONOTONIC, &end);
     .      .  132:       total_time += (end.tv_sec - start.tv_sec)*1000000000 + (end.tv_nsec - start.tv_nsec);
     .     67  133:       e = SortedList_lookup(&(sublists[list_id].head), elements[i].key);
     .      .  134:       if(e == NULL) {
     .      .  135: 	fprintf(stderr, "Failure in looking up list element\n");
     .      .  136: 	exit(2);
     .      .  137:       }
     .      .  138:       rc = SortedList_delete(e);
     .      .  139:       if(rc == 1) {
     .      .  140: 	fprintf(stderr, "Failure in deleting list element\n");
     .      .  141: 	exit(2);
     .      .  142:       }
     .      .  143:       __sync_lock_release(&(sublists[list_id].lock));
     .      .  144:     }
     .      .  145:     else{
     .      .  146:       e = SortedList_lookup(&(sublists[list_id].head), elements[i].key);
     .      .  147:       if(e == NULL) {
     .      .  148: 	fprintf(stderr, "Failure in looking up list element\n");
     .      .  149: 	exit(2);
     .      .  150:       }
     .      .  151:       rc = SortedList_delete(e);
     .      .  152:       if(rc == 1) {
     .      .  153: 	fprintf(stderr, "Failure in deleting list element\n");
     .      .  154: 	exit(2);
     .      .  155:       }
     .      .  156:     }
     .      .  157:   }
     .      .  158:   pthread_exit((void *)total_time);
---
     .      .  159: }
     .      .  160: int main(int argc, char **argv)
     .      .  161: {
     .      .  162:   int opt;
     .      .  163:   struct option long_options[] = {{"threads", required_argument, NULL, 't'},
